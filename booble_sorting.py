"""
Пузырьковая сортировка

Этот простой алгоритм выполняет итерации по списку, сравнивая элементы попарно и меняя их местами,
пока более крупные элементы не «всплывут» в начало списка, а более мелкие не останутся на «дне».
Алгоритм

Сначала сравниваются первые два элемента списка. Если первый элемент больше, они меняются местами.
Если они уже в нужном порядке, оставляем их как есть. Затем переходим к следующей паре элементов,
сравниваем их значения и меняем местами при необходимости. Этот процесс продолжается до последней
пары элементов в списке.

При достижении конца списка процесс повторяется заново для каждого элемента. Это крайне неэффективно,
если в массиве нужно сделать, например, только один обмен. Алгоритм повторяется n² раз,
даже если список уже отсортирован.

Для оптимизации алгоритма нужно знать, когда его остановить, то есть когда список отсортирован.

Чтобы остановить алгоритм по окончании сортировки, нужно ввести переменную-флаг.
Когда значения меняются местами, устанавливаем флаг в значение True, чтобы повторить процесс сортировки.
Если перестановок не произошло, флаг остаётся False и алгоритм останавливается.
"""
import numpy as np


# Реализация
def main(aray):
    def bubble_sort(aray):
        """
        Алгоритм работает в цикле while и прерывается, когда элементы ни разу не меняются местами.
        Вначале присваиваем swapped значение True, чтобы алгоритм запустился хотя бы один раз.

        :param aray:
        :return:
        """
        # Устанавливаем swapped в True, чтобы цикл запустился хотя бы 1 раз
        swapped = True
        while swapped:
            swapped = False
            for i in range(len(aray) - 1):
                if aray[i] > aray[i + 1]:
                    # Меняем элементы
                    aray[i], aray[i + 1] = aray[i + 1], aray[i]
                    # Устанавливаем swapped в True для следующей итерации
                    swapped = True
        """
        Время сортировки
        
        Если взять самый худший случай (изначально список отсортирован по убыванию), 
        затраты времени будут равны O(n²), где n — количество элементов списка.
        """
        return aray

    return bubble_sort(aray=aray)


samples = np.random.randint(0, 10, 10)

# Press the green button in the gutter to run the script.
if __name__ == '__main__':
    print(f'samples: {samples}')
    sorted_samples = main(samples)
    print(f'sorted_samples: {sorted_samples}')